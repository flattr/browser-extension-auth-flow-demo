
# Publisher website

> Note that the certificates used for signing will likely change before this goes live.

## Checking if the visitor is a paying Flattr user

The visiting extension will attach an event listener (`flattr-request-payload`) on the document. Trigger this event to request the payload. The extension will then respond with the event `flattr-payload` with an attached cryptographically signed and encoded string.

Example response:

```json
{
  "payload": "Gwx7MU+Nmh4tBVhhGeoXjoWOQXrsgqTWgMI+QwuWrWfF0aJ4OAMB5zyJKpA9+pTTGJzP6rVEzZw"
}
```

### <a name="payload">Payload structure</a>

In its compact form the payload consists of two base64 encoded parts separated by a dot (`.`). These are:

* Data
* Signature

Therefore, the payload looks something like this:

`xxxx.yyyyyyyyyyyyyyyy`

Let's break down the different parts:

#### 1. Data

The first part is the actual data about the user, in the form of a JSON object. There are currently
two properties; `isPaying` and `expiresAt`.

Example JSON data could be:

	{
	  "isPaying": true,
	  "expiresAt": 1603885771
	}

`expiresAt` specifies when the payload expires as a [unix timestamp](https://en.wikipedia.org/wiki/Unix_time).

The JSON object is then base64 encoded to form the first part of the payload.

#### 2. Signature

The second and last part of the payload is the data signature. The signature is used to verify that the message was not changed along the way and to verify that the payload is from Flattr.

The signature is generated by cryptographically signing the (unencoded) data part of the payload and then base64 encoding the result. The algorithm used is currently RSA with SHA-256.

### Verifying the payload signature
Before we can use it we need to verify the signature of the data. In our example we'll be using the `SubtleCrypto` browser API; however the process should be somewhat similar regardless of workflow.

#### 1. Create a `CryptoKey` from the public key

Import the public key into the `SubtleCrypto` interface using the `window.crypto.subtle.importKey` method. This will return a `CryptoKey` that we can use to verify the payload later on.

The method takes 5 arguments:

1. `format` – "spki" (SubjectPublicKeyInfo).
1. `keyData` – The public key as an `ArrayBuffer`.
	1. The public key is originally in the [PEM format](https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail). We need it to be a raw base64 encoded string, so strip its header and footer.
	1. Then decode and [convert the raw key into an `ArrayBuffer`](#key-to-array-buffer).
1. `algorithm` – RSA with SHA-256.
1. `extractable` – Set to `false` because we will not export this `CryptoKey`.
1. `keyUsages` – an array indicating what can be done with the key. In our example we'll use the key to verify the signature, hence we set it to `['verify']`.

#### 2. Verify the data signature

The `window.crypto.subtle.verify` method takes 4 arguments.

1. `algorithm` – RSA with SHA-256.
1. `key` – A `CryptoKey` interface.
1. `signature` – An `ArrayBuffer` containing the signature to verify.
1. `data` – An `ArrayBuffer` containing the data whose signature is to be verified.

See ["converting a key into an ArrayBuffer"](#key-to-array-buffer) for more information about creating the array buffers.

#### <a name="key-to-array-buffer">Converting a key into an `ArrayBuffer`</a>

Below is example code for converting a raw base 64 encoded key into an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer).

	const keyToArrayBuffer = function (rawKey) {
	  const decoded = window.atob(rawKey)
	  const buffer = new ArrayBuffer(decoded.length)
	  let bytes = new Uint8Array(buffer)

	  for (let i = 0; i < decoded.length; i++) {
	    bytes[i] = decoded.charCodeAt(i)
	  }

	  return bytes
	}

## Demo

[Example webpage](demo/index.html)

[Example JS](demo/main.js)