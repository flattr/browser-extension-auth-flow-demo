
# Publisher website

> Note that the certificates used for signing will likely change before this goes live.

## Checking if the visitor is a paying Flattr user

The visiting extension will expose an api endpoint if there is an active user, calling it will instantly return a [payload](#payload) to be validated.
```js
FlattrExt.isPayingUser(): payload
```

### <a name="payload">Payload structure</a>

In its compact form the payload consists of two base64 encoded parts separated by a dot (`.`). These are:

* Data
* Signature

Therefore, the payload looks something like this:

`xxxx.yyyyyyyyyyyyyyyy`

Let's break down the different parts:

#### 1. Data

The first part is the actual data about the user, in the form of a JSON object. There are currently
two properties; `isPaying` and `expiresAt`.

Example JSON data could be:

	{
	  "isPaying": true,
	  "expiresAt": 1603885771
	}

`expiresAt` specifies when the payload expires as a unix timestamp.

The JSON object is then base64 encoded to form the first part of the payload.

#### 2. Signature

The second and last part of the payload is the data signature. The signature is used to verify that the message was not changed along the way and to verify that the payload is from Flattr.

The signature is generated by cryptographically signing the (encoded) data part of the payload and then base64 encoding the result. The algorithm used is currently RSA with SHA-256.

### Verifying the payload signature
Before we can use it we need to verify the signature of the data. In our example we'll be using the `SubtleCrypto` browser API; however the process should be somewhat similar regardless of workflow.

#### 1. Create a `CryptoKey` from the public key

Import the public key into the `SubtleCrypto` interface using the [`crypto.subtle.importKey`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey) method. This will return a `CryptoKey` that we can use to verify the payload later on.

The public key is originally in the [PEM format](https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail). We need it to be an ArrayBuffer

1. so we strip its header and footer to get a raw base64 encoded string.
1. Then base64 decode and [convert the raw key into an `ArrayBuffer`](#to-array-buffer).

We now have a key that can be used by `importKey`.

	const importedKey = await window.crypto.subtle.importKey(
	  'spki',
	  flattrPublicKey,
	  algorithm,
	  false,
	  ['verify']
	)

  
#### 2. Verify the data signature

Using the imported key we can now verify the payload signature using [crypto.subtle.verify](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/verify), but first we need to prepare the data and signature for use with `crypto.subtle.verify`.

The data and signature parts of the payload are both base64 encoded strings and in order to use them we need to turn them both into [`ArrayBuffers`](#to-array-buffer). The signature will also have to be base64 decoded before use.


    const isValid = await window.crypto.subtle.verify(
      algorithm,
      importedKey,
      toArrayBuffer(window.atob(signature)),
      toArrayBuffer(data)
    )


#### <a name="to-array-buffer">Converting a string into an `ArrayBuffer`</a>

Below is example code for converting a string into an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer).

	const toArrayBuffer = function (str) {
	  const buffer = new ArrayBuffer(str.length)
	  let bytes = new Uint8Array(buffer)

	  for (let i = 0; i < str.length; i++) {
	    bytes[i] = str.charCodeAt(i)
	  }

	  return bytes
	}

## Demo

[Example webpage](demo/index.html)

[Example JS](demo/main.js)