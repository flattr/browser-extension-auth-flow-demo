# Client demo
WIP: Include info about how it works here.

## Checking if the visitor is a paying Flattr user

The visiting extension will expose an api endpoint if there is an active user, calling it will instantly return the below specified [payload](#payload) for user validation.
```js
FlattrExt.isPayingUser(): payload
```

### Payload structure<a name="payload"></a>

In its compact form the payload will consist of two base64 encoded parts separated by a dot ( . ), which are:

* data
* signature

Therefore, a payload will look like the following.

`xxxx.yyyyyyyyyyyyyyyy`

Let's break down the different parts.

**Data**

The first part is the actual data about the user, in the form of a json object. There are currently
two properties: isPaying and expiresAt.

Example JSON data could be:

	{
	  "isPaying": true,
	  "expiresAt": 1603885771
	}

The JSON object is then base64 encoded to form the first part of the payload.

**Signature**

The second and last part of the payload is the data signature. The signature is used to verify that the message wasn't changed along the way and to verify that the payload is from Flattr.

The signature is generated by cryptographically signing the (unencoded) data part of the payload and then base64 encoding the result. The algorithm used is currently RSA with SHA-256.

**So what's going on here anyway**

In our example we'll be using SubtleCrypto, however, if you're using another API the principle would most likely be somwhat similar.

[Example webpage](demo/index.html)
[Example JS](demo/main.js)

**Verifying the payload signature**

**1: Import PublicKey**

The importKey() method takes 5 arguments.

	{
	  format: spki (SubjectPublicKeyInfo),
	  keyData: PublicKey as an ArrayBuffer,
	  algorithm: RSA with SHA-256,
	  extractable: false
	  keyUsages: ['verify']
	}

We're using the [PEM format](https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail) for our PublicKey.

PublicKey needs to be a raw base64 string, therefor removing:
```
-----BEGIN PUBLIC KEY-----
-----END PUBLIC KEY-----
```

Also base64-decode the part between header and footer, using [window.atob()](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/atob).

Extractable is set to false because we will not export this CryptoKey.

keyUsages is an Array indicating what can be done with the key. In our example we'll use the key to verify the signature.
`['verify']`

Import the PublicKey into a CryptoKey object using the importKey() method. This will return a CryptoKey object that we can use to verify the payload later on.

**2: Verify**

The SubtleCrypto verify() method takes 5 arguments.

	{
	  algorithm: RSA with SHA-256,
	  key: CryptoKey Object,
	  signature: ArrayBuffer containing the signature to verify,
	  data: ArrayBuffer containing the data whose signature is to be verified,
	}


Convert the signature and data into [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) and pass it along with the CryptoKey Object to the verify method.

