
# Publisher website

> Note that the certificates used for signing will likely change before this goes live.

## Checking if the visitor is a paying Flattr user

The visiting extension will attach an event listener (`flattr-request-payload`) on the document. Trigger this event to request the payload. The extension will then respond with the event `flattr-payload` with an attached cryptographically signed and encoded string.

Example response:

```json
{
  "payload": "Gwx7MU+Nmh4tBVhhGeoXjoWO.QXrsgqTWgMI+QwuWrWfF0aJ4OAMB5zyJKpA9+pTTGJzP6rVEzZw"
}
```

### <a name="payload">Payload structure</a>

In its compact form the payload consists of two base64 encoded parts separated by a dot (`.`). These are:

* Data
* Signature

Therefore, the payload looks something like this:

`xxxx.yyyyyyyyyyyyyyyy`

Let's break down the different parts:

#### 1. Data

The first part is the actual data about the user, in the form of a JSON object. There are currently
two properties; `isPaying` and `expiresAt`.

Example JSON data could be:

```JSON
{
  "isPaying": true,
  "expiresAt": 1603885771
}
```

`expiresAt` specifies when the payload expires as a [unix timestamp](https://en.wikipedia.org/wiki/Unix_time).

The JSON object is then base64 encoded to form the first part of the payload.

#### 2. Signature

The second and last part of the payload is the data signature. The signature is used to verify that the message was not changed along the way and to verify that the payload is from Flattr.

The signature is generated by cryptographically signing the (encoded) data part of the payload and then base64 encoding the result. The algorithm used is currently RSA with SHA-256.

### Verifying the payload signature
Before we can use it we need to verify the signature of the data. In our example we'll be using the `SubtleCrypto` browser API; however the process should be somewhat similar regardless of workflow.

#### 1. Create a `CryptoKey` from the public key

In order to verify the payload we first need to import it into the `SubtleCrypto` interface using the [`crypto.subtle.importKey`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey) method. This will return a `CryptoKey` that we can use later on.

The public key is originally in the [PEM format](https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail) but we need it to be an ArrayBuffer. To get there we need to do the following:

1. Strip the header and footer ("-----BEGIN PUBLIC KEY-----" and "-----END PUBLIC KEY-----") in order to get the raw base64 encoded string.
1. Base64 decode said string.
1. [Convert the now decoded string into an `ArrayBuffer`](#to-array-buffer).

This gives us a key that can be used by `importKey`.

```javascript
const importedKey = await window.crypto.subtle.importKey(
  'spki',
  publicKey,
  algorithm,
  false,
  ['verify']
)
```
  
#### 2. Verify the data signature

Before we can verify the payload signature we need to prepare the data and
signature parts of the payload. Both parts are base64 encoded strings and we need to [turn them both into array buffers](#to-array-buffer). We also need to base64 decode the signature before use.

Lastly, using the imported key from the last step we can now verify the payload signature using [crypto.subtle.verify](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/verify):

```javascript
const isValid = await window.crypto.subtle.verify(
  algorithm,
  importedKey,
  toArrayBuffer(window.atob(signature)),
  toArrayBuffer(data)
)
```


#### <a name="to-array-buffer">Converting a string into an `ArrayBuffer`</a>

Below is example code for converting a string into an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer).

```javascript
const toArrayBuffer = function (str) {
  const buffer = new ArrayBuffer(str.length)
  let bytes = new Uint8Array(buffer)

  for (let i = 0; i < str.length; i++) {
    bytes[i] = str.charCodeAt(i)
  }

  return bytes
}
```

## Demo

[Example webpage](demo/index.html)

[Example JS](demo/main.js)
